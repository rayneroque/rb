#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <cctype>
using namespace std;

const string ALLOWED_ROOM_TYPES[] = {
    "Classroom", "Faculty", "Laboratory Room", "Computer Laboratory", "Electrical Room"
};
const string ALLOWED_ISSUES[] = {
    "Cleaning Maintenance",
    "Repair Maintenance",
    "Equipment Maintenance"
};

struct Room {
    string number, type, issue;
    int floor;
};

struct PendingRequest {
    string number, issue;
};

vector<Room> rooms = {
    {"101", "Classroom", "Cleaning Maintenance", 1},
    {"102", "Classroom", "No issue", 1},
    {"CPE Faculty", "Faculty", "Cleaning Maintenance", 1},
    {"302", "Classroom", "No issue", 3},
    {"201", "Stock Room", "Equipment Maintenance", 2},
    {"302A", "Classroom", "Repair Maintenance", 3},
    {"CLR1", "Computer Laboratory", "Equipment Maintenance, Cleaning Maintenance", 2},
    {"ECE1", "Electrical Room", "Equipment Issue", 2},
    {"102A", "Laboratory Room", "Cleaning Maintenance", 1},
    {"419", "Classroom", "No issue", 4},
    {"CLR4", "Computer Laboratory", "Equipment Maintenance", 2},
    {"CLR2", "Computer Laboratory", "Equipment Maintenance", 2},
    {"EE Faculty", "Faculty", "Cleaning Maintenance", 1},
    {"317", "Classroom", "No issue", 3},
    {"421", "Classroom", "Cleaning Maintenance, Equipment Maintenance", 4},
    {"117", "Laboratory Room", "Repair Maintenance", 1},
    {"CE Faculty", "Faculty", "Repair Maintenance", 1},
    {"402", "Classroom", "Repair Maintenance", 4}
};
vector<PendingRequest> pending;

void showRoom(const Room& r) {
    cout << "\nRoom " << r.number << "\nType: " << r.type
         << "\nIssue: " << r.issue << "\n-------------------------\n";
}

// Helper: true if fully numeric, false otherwise
bool isFullyNumeric(const string& s) {
    if (s.empty()) return false;
    for (char c : s) if (!isdigit(c)) return false;
    return true;
}

void showRoomsByFloor() {
    int floor;
    cout << "\nEnter floor (1-4): "; cin >> floor;
    // Collect all rooms for the given floor
    vector<Room> filtered;
    for (const auto& r : rooms)
        if (r.floor == floor)
            filtered.push_back(r);

    if (filtered.empty()) {
        cout << "No rooms on this floor.\n";
        return;
    }

    // Sort: numeric room numbers first (in numeric order!), then others (CLR/ECE/etc) lex
    sort(filtered.begin(), filtered.end(), [](const Room& a, const Room& b) {
        bool a_num = isFullyNumeric(a.number);
        bool b_num = isFullyNumeric(b.number);
        if (a_num && !b_num) return true;
        if (!a_num && b_num) return false;
        // Both numeric: sort numerically
        if (a_num && b_num) return stoi(a.number) < stoi(b.number);
        // Both non-numeric: group CLR/ECE together, then lex
        auto isCLRorECE = [](const string& num) {
            return num.find("CLR") == 0 || num.find("ECE") == 0;
        };
        bool a_clr_ece = isCLRorECE(a.number);
        bool b_clr_ece = isCLRorECE(b.number);
        if (a_clr_ece && !b_clr_ece) return true;
        if (!a_clr_ece && b_clr_ece) return false;
        // Both CLR/ECE or both not: sort lexicographically
        return a.number < b.number;
    });

    for (const auto& r : filtered)
        showRoom(r);
}

void searchRoomsByNumber() {
    cin.ignore();
    cout << "Enter room number to search: ";
    string key; getline(cin, key);
    bool found = false;
    for (const auto& r : rooms) {
        if (r.number.find(key) != string::npos) {
            showRoom(r); found = true;
        }
    }
    if (!found) cout << "No rooms found with that number.\n";
}

void searchRoomsByType() {
    cout << "\nAvailable Room Types:\n";
    for (int i = 0; i < 5; ++i)
        cout << i+1 << ". " << ALLOWED_ROOM_TYPES[i] << endl;
    int choice;
    cout << "Select Room Type (1-5): "; cin >> choice;
    if (choice < 1 || choice > 5) { cout << "Invalid choice.\n"; return; }
    string type = ALLOWED_ROOM_TYPES[choice-1];
    bool found = false;
    for (const auto& r : rooms)
        if (r.type == type) { showRoom(r); found = true; }
    if (!found) cout << "No rooms of this type.\n";
}

void searchRoomsByIssue() {
    cout << "\nAvailable Issues:\n";
    for (int i = 0; i < 3; ++i)
        cout << i+1 << ". " << ALLOWED_ISSUES[i] << endl;
    int choice;
    cout << "Select Issue Type (1-3): "; cin >> choice;
    if (choice < 1 || choice > 3) { cout << "Invalid choice.\n"; return; }
    string issue = ALLOWED_ISSUES[choice-1];
    bool found = false;
    for (const auto& r : rooms)
        if (r.issue.find(issue) != string::npos) { showRoom(r); found = true; }
    if (!found) cout << "No rooms with this issue.\n";
}

void searchRoomsMenu() {
    while (true) {
        cout << "\nSearch Rooms by:\n";
        cout << "[1] Room Number\n[2] Room Type\n[3] Issues\n[0] Back\nChoice: ";
        int ch; cin >> ch;
        if (cin.fail()) { cin.clear(); cin.ignore(10000,'\n'); continue; }
        if (ch == 1) searchRoomsByNumber();
        else if (ch == 2) searchRoomsByType();
        else if (ch == 3) searchRoomsByIssue();
        else if (ch == 0) break;
        else cout << "Invalid option.\n";
    }
}

bool isDuplicateReq(const string& num, const string& issue) {
    for (const auto& req : pending)
        if (req.number == num && req.issue == issue)
            return true;
    return false;
}

void requestIssue() {
    cin.ignore();
    cout << "Enter room number: "; string num; getline(cin, num);
    auto it = find_if(rooms.begin(), rooms.end(),
        [&](const Room& r){ return r.number == num; });
    if (it == rooms.end()) { cout << "Room not found.\n"; return; }

    cout << "Select issue type:\n";
    for (int i = 0; i < 3; ++i)
        cout << i+1 << ". " << ALLOWED_ISSUES[i] << endl;
    int choice; cin >> choice;
    if (choice < 1 || choice > 3) { cout << "Invalid choice.\n"; return; }
    string issue = ALLOWED_ISSUES[choice-1];

    if (isDuplicateReq(num, issue)) {
        cout << "There is already a pending request for this issue in this room.\n";
        return;
    }
    it->issue = issue;
    pending.push_back({num, issue});
    cout << "Request added.\n";
}

void showPending() {
    if (pending.empty()) { cout << "No pending requests.\n"; return; }
    // Sort by floor then room number (with same logic as showRoomsByFloor)
    vector<pair<int,string>> order;
    for (const auto& req : pending) {
        auto rit = find_if(rooms.begin(), rooms.end(),
            [&](const Room& r){ return r.number == req.number; });
        int fl = rit != rooms.end() ? rit->floor : 99;
        order.push_back({fl, req.number});
    }
    sort(order.begin(), order.end(), [](const pair<int,string>& a, const pair<int,string>& b){
        if (a.first != b.first) return a.first < b.first;
        // Use same logic as showRoomsByFloor for ordering number
        bool a_num = isFullyNumeric(a.second);
        bool b_num = isFullyNumeric(b.second);
        if (a_num && !b_num) return true;
        if (!a_num && b_num) return false;
        if (a_num && b_num) return stoi(a.second) < stoi(b.second);
        // Both non-numeric: group CLR/ECE together, then lex
        auto isCLRorECE = [](const string& num) {
            return num.find("CLR") == 0 || num.find("ECE") == 0;
        };
        bool a_clr_ece = isCLRorECE(a.second);
        bool b_clr_ece = isCLRorECE(b.second);
        if (a_clr_ece && !b_clr_ece) return true;
        if (!a_clr_ece && b_clr_ece) return false;
        return a.second < b.second;
    });
    cout << "\nPending Requests:\n";
    for (const auto& o : order) {
        auto rit = find_if(rooms.begin(), rooms.end(),
            [&](const Room& r){ return r.number == o.second; });
        if (rit != rooms.end()) showRoom(*rit);
    }
}

int main() {
    cout << "***** fixENrequest *****\n";
    while (true) {
        cout << "\n       Main Menu    ";
        cout << "\n[1] Show Rooms\n[2] Search Rooms\n[3] Request Issue\n[4] Pending Requests\n[0] Exit\n\nChoice: ";
        int ch; cin >> ch;
        if (cin.fail()) { cin.clear(); cin.ignore(10000,'\n'); continue; }
        if (ch == 1) showRoomsByFloor();
        else if (ch == 2) searchRoomsMenu();
        else if (ch == 3) requestIssue();
        else if (ch == 4) showPending();
        else if (ch == 0) break;
        else cout << "Invalid option.\n";
    }
    return 0;
}
